--- src/io/trove/trove-dbpf/dbpf-bstream-direct.c
+++ src/io/trove/trove-dbpf/dbpf-bstream-direct.c
@@ -532,928 +534,943 @@
  * @return number of bytes read
  */
 static size_t direct_aligned_read(int fd,
-                                   void * buf,
-                                   off_t buf_offset,
-                                   size_t size,
-                                   off_t file_offset,
-                                   off_t stream_size)
+		void * buf,
+		off_t buf_offset,
+		size_t size,
+		off_t file_offset,
+		off_t stream_size)
 {
-    int ret;
+	int ret;
 
-    if(file_offset >= stream_size)
-    {
-        /* the offset is past EOF, return 0 bytes read */
-        return 0;
-    }
+	if(file_offset >= stream_size)
+	{
+		/* the offset is past EOF, return 0 bytes read */
+		return 0;
+	}
 
 #ifndef NDEBUG
-    /* if debug is enabled, check that fd was opened with O_DIRECT */
-
-    if(!(fcntl(fd, F_GETFL) & O_DIRECT))
-    {
-        gossip_err("dbpf_direct_read: trying to do direct IO but file wasn't "
-                   "opened with O_DIRECT\n");
-        return -EINVAL;
-    }
+	/* if debug is enabled, check that fd was opened with O_DIRECT */
+
+	if(!(fcntl(fd, F_GETFL) & O_DIRECT))
+	{
+		gossip_err("dbpf_direct_read: trying to do direct IO but file wasn't "
+				"opened with O_DIRECT\n");
+		return -EINVAL;
+	}
 #endif
 
-    /* verify that stuff is aligned properly */
-    assert(IS_ALIGNED_PTR(buf));
-    assert(ALIGNED_OFFSET(buf_offset) == buf_offset);
-    assert(ALIGNED_SIZE(file_offset, size) == size);
-    assert(ALIGNED_OFFSET(file_offset) == file_offset);
+	/* verify that stuff is aligned properly */
+	assert(IS_ALIGNED_PTR(buf));
+	assert(ALIGNED_OFFSET(buf_offset) == buf_offset);
+	assert(ALIGNED_SIZE(file_offset, size) == size);
+	assert(ALIGNED_OFFSET(file_offset) == file_offset);
 
-    ret = dbpf_pread(fd, (((char *)buf) + buf_offset), size, file_offset);
-    if(ret < 0)
-    {
-        gossip_err("dbpf_direct_read: failed to perform aligned read\n");
-        return -trove_errno_to_trove_error(errno);
-    }
+	ret = dbpf_pread(fd, (((char *)buf) + buf_offset), size, file_offset);
+	if(ret < 0)
+	{
+		gossip_err("dbpf_direct_read: failed to perform aligned read\n");
+		return -trove_errno_to_trove_error(errno);
+	}
 
-    return ret;
+	return ret;
 }
 
 static size_t direct_locked_read(int fd,
-                           void * buf,
-                           off_t buf_offset,
-                           size_t size,
-                           off_t file_offset,
-                           off_t stream_size)
+		void * buf,
+		off_t buf_offset,
+		size_t size,
+		off_t file_offset,
+		off_t stream_size)
 {
-    int ret, read_ret;
-    struct flock readlock;
-
-    readlock.l_type = F_RDLCK;
-    readlock.l_whence = SEEK_SET;
-    readlock.l_start = (off_t)ALIGNED_OFFSET(file_offset);
-    readlock.l_len = (off_t)ALIGNED_SIZE(file_offset, size);
-    ret = fcntl(fd, F_SETLKW, &readlock);
-    if(ret < 0 && errno == EINTR)
-    {
-        return -trove_errno_to_trove_error(errno);
-    }
-    readlock.l_type = F_UNLCK;
-
-    read_ret = direct_read(fd, buf, buf_offset, size, file_offset, stream_size);
-
-    ret = fcntl(fd, F_SETLK, &readlock);
-    if(ret < 0)
-    {
-        return -trove_errno_to_trove_error(errno);
-    }
-
-    return read_ret;
+	int ret, read_ret;
+	struct flock readlock;
+
+	readlock.l_type = F_RDLCK;
+	readlock.l_whence = SEEK_SET;
+	readlock.l_start = (off_t)ALIGNED_OFFSET(file_offset);
+	readlock.l_len = (off_t)ALIGNED_SIZE(file_offset, size);
+	ret = fcntl(fd, F_SETLKW, &readlock);
+	if(ret < 0 && errno == EINTR)
+	{
+		return -trove_errno_to_trove_error(errno);
+	}
+	readlock.l_type = F_UNLCK;
+
+	read_ret = direct_read(fd, buf, buf_offset, size, file_offset, stream_size);
+
+	ret = fcntl(fd, F_SETLK, &readlock);
+	if(ret < 0)
+	{
+		return -trove_errno_to_trove_error(errno);
+	}
+
+	return read_ret;
 }
 
 static size_t direct_read(int fd,
-                           void * buf,
-                           off_t buf_offset,
-                           size_t size,
-                           off_t file_offset,
-                           off_t stream_size)
+		void * buf,
+		off_t buf_offset,
+		size_t size,
+		off_t file_offset,
+		off_t stream_size)
 {
-    void * aligned_buf;
-    off_t aligned_offset;
-    size_t aligned_size, read_size;
-    size_t ret;
-
-    if(file_offset > stream_size)
-    {
-        return 0;
-    }
-
-    read_size = size;
-    if(stream_size < (file_offset + size))
-    {
-        read_size = stream_size - file_offset;
-    }
-
-    aligned_offset = ALIGNED_OFFSET(file_offset);
-    aligned_size = ALIGNED_SIZE(file_offset, read_size);
-
-    if(IS_ALIGNED_PTR(buf) &&
-       ALIGNED_OFFSET(buf_offset) == buf_offset &&
-       aligned_size == read_size)
-    {
-        return direct_aligned_read(fd, buf, buf_offset, read_size, 
-                                   file_offset, stream_size);
-    }
-
-    aligned_buf = PINT_mem_aligned_alloc(aligned_size, BLOCK_SIZE);
-    if(!aligned_buf)
-    {
-        return -ENOMEM;
-    }
-
-    ret = direct_aligned_read(fd, aligned_buf, 0, aligned_size, 
-                               aligned_offset, stream_size);
-    if(ret < 0)
-    {
-        PINT_mem_aligned_free(aligned_buf);
-
-        return ret;
-    }
-
-    memcpy(((char *)buf) + buf_offset,
-           ((char *)aligned_buf) + (file_offset - aligned_offset),
-           read_size);
-
-    PINT_mem_aligned_free(aligned_buf);
-
-    return read_size;
+	void * aligned_buf;
+	off_t aligned_offset;
+	size_t aligned_size, read_size;
+	size_t ret;
+
+	if(file_offset > stream_size)
+	{
+		return 0;
+	}
+
+	read_size = size;
+	if(stream_size < (file_offset + size))
+	{
+		read_size = stream_size - file_offset;
+	}
+
+	aligned_offset = ALIGNED_OFFSET(file_offset);
+	aligned_size = ALIGNED_SIZE(file_offset, read_size);
+
+	if(IS_ALIGNED_PTR(buf) &&
+			ALIGNED_OFFSET(buf_offset) == buf_offset &&
+			aligned_size == read_size)
+	{
+		return direct_aligned_read(fd, buf, buf_offset, read_size, 
+				file_offset, stream_size);
+	}
+
+	aligned_buf = PINT_mem_aligned_alloc(aligned_size, BLOCK_SIZE);
+	if(!aligned_buf)
+	{
+		return -ENOMEM;
+	}
+
+	ret = direct_aligned_read(fd, aligned_buf, 0, aligned_size, 
+			aligned_offset, stream_size);
+	if(ret < 0)
+	{
+		PINT_mem_aligned_free(aligned_buf);
+
+		return ret;
+	}
+
+	memcpy(((char *)buf) + buf_offset,
+			((char *)aligned_buf) + (file_offset - aligned_offset),
+			read_size);
+
+	PINT_mem_aligned_free(aligned_buf);
+
+	return read_size;
 }
 
 static int dbpf_bstream_direct_read_op_svc(void *ptr, PVFS_hint hint)
 {
-    int ret = -TROVE_EINVAL;
-    TROVE_object_ref ref;
-    TROVE_ds_attributes attr;
-    dbpf_queued_op_t *qop_p;
-    struct dbpf_bstream_rw_list_op *rw_op;
-    dbpf_stream_extents_t *stream_extents = NULL;
-    int i, extent_count;
-
-    rw_op = (struct dbpf_bstream_rw_list_op *)ptr;
-    qop_p = (dbpf_queued_op_t *)rw_op->queued_op_ptr;
-
-    ref.fs_id = qop_p->op.coll_p->coll_id;
-    ref.handle = qop_p->op.handle;
-
-    /* not in attribute cache.  get the size from dspace */
-    ret = dbpf_dspace_attr_get(qop_p->op.coll_p, ref, &attr);
-    if(ret != 0)
-    {
-        gossip_err("%s: failed to get size in dspace attr: (error=%d)\n", __func__, ret);
-        goto done;
-    }
-
-    ret = dbpf_bstream_get_extents(
-        rw_op->mem_offset_array,
-        rw_op->mem_size_array,
-        rw_op->mem_array_count,
-        rw_op->stream_offset_array,
-        rw_op->stream_size_array,
-        rw_op->stream_array_count,
-        &extent_count,
-        NULL);
-    if(ret != 0)
-    {
-        gossip_err("%s: failed to get bstream extents from offset/sizes: (error=%d)\n", __func__, ret);
-        goto done;
-    }
-
-    stream_extents = malloc(sizeof(*stream_extents) * extent_count);
-    if(!stream_extents)
-    {
-        return -TROVE_ENOMEM;
-    }
-
-    ret = dbpf_bstream_get_extents(
-        rw_op->mem_offset_array,
-        rw_op->mem_size_array,
-        rw_op->mem_array_count,
-        rw_op->stream_offset_array,
-        rw_op->stream_size_array,
-        rw_op->stream_array_count,
-        &extent_count,
-        stream_extents);
-    if(ret != 0)
-    {
-        gossip_err("%s: failed to get bstream extents from offset/sizes: (error=%d)\n", __func__, ret);
-        goto done;
-    }
-
-    for(i = 0; i < extent_count; ++ i)
-    {
-        ret = direct_locked_read(rw_op->open_ref.fd,
-                          stream_extents[i].buffer,
-                          0,
-                          stream_extents[i].size,
-                          stream_extents[i].offset,
-                          attr.u.datafile.b_size);
-        if(ret < 0)
-        {
-            ret = -trove_errno_to_trove_error(-ret);
-            gossip_err("%s: direct_locked_read failed: (error=%d)\n", __func__, ret);
-            goto done;
-        }
-    }
-
-    ret = DBPF_OP_COMPLETE;
-
-done:
-    if(stream_extents)
-    {
-        free(stream_extents);
-    }
-    dbpf_open_cache_put(&rw_op->open_ref);
-    return ret;
+	int ret = -TROVE_EINVAL;
+	TROVE_object_ref ref;
+	TROVE_ds_attributes attr;
+	dbpf_queued_op_t *qop_p;
+	struct dbpf_bstream_rw_list_op *rw_op;
+	dbpf_stream_extents_t *stream_extents = NULL;
+	int i, extent_count;
+
+	rw_op = (struct dbpf_bstream_rw_list_op *)ptr;
+	qop_p = (dbpf_queued_op_t *)rw_op->queued_op_ptr;
+
+	ref.fs_id = qop_p->op.coll_p->coll_id;
+	ref.handle = qop_p->op.handle;
+
+	/* not in attribute cache.  get the size from dspace */
+	ret = dbpf_dspace_attr_get(qop_p->op.coll_p, ref, &attr);
+	if(ret != 0)
+	{
+		gossip_err("%s: failed to get size in dspace attr: (error=%d)\n", __func__, ret);
+		goto done;
+	}
+
+	ret = dbpf_bstream_get_extents(
+			rw_op->mem_offset_array,
+			rw_op->mem_size_array,
+			rw_op->mem_array_count,
+			rw_op->stream_offset_array,
+			rw_op->stream_size_array,
+			rw_op->stream_array_count,
+			&extent_count,
+			NULL);
+	if(ret != 0)
+	{
+		gossip_err("%s: failed to get bstream extents from offset/sizes: (error=%d)\n", __func__, ret);
+		goto done;
+	}
+
+	stream_extents = malloc(sizeof(*stream_extents) * extent_count);
+	if(!stream_extents)
+	{
+		return -TROVE_ENOMEM;
+	}
+
+	ret = dbpf_bstream_get_extents(
+			rw_op->mem_offset_array,
+			rw_op->mem_size_array,
+			rw_op->mem_array_count,
+			rw_op->stream_offset_array,
+			rw_op->stream_size_array,
+			rw_op->stream_array_count,
+			&extent_count,
+			stream_extents);
+	if(ret != 0)
+	{
+		gossip_err("%s: failed to get bstream extents from offset/sizes: (error=%d)\n", __func__, ret);
+		goto done;
+	}
+
+	for(i = 0; i < extent_count; ++ i)
+	{	
+
+		HD_SERVER_TROVE_RELATION(hint,"read",
+				ret = direct_locked_read(rw_op->open_ref.fd,
+						stream_extents[i].buffer,
+						0,
+						stream_extents[i].size,
+						stream_extents[i].offset,
+						attr.u.datafile.b_size);,
+				"%d",ret,
+				"%lld",lld(stream_extents[i].offset)
+		)
+
+		if(ret < 0)
+		{
+			ret = -trove_errno_to_trove_error(-ret);
+			gossip_err("%s: direct_locked_read failed: (error=%d)\n", __func__, ret);
+			goto done;
+		}
+
+	}
+
+	ret = DBPF_OP_COMPLETE;
+
+	done:
+	if(stream_extents)
+	{
+		free(stream_extents);
+	}
+	dbpf_open_cache_put(&rw_op->open_ref);
+	return ret;
 }
 
 static int dbpf_bstream_direct_write_op_svc(void *ptr, PVFS_hint hint)
 {
-    int ret = -TROVE_EINVAL;
-    TROVE_object_ref ref;
-    TROVE_ds_attributes attr;
-    dbpf_stream_extents_t *stream_extents = NULL;
-    int i, extent_count;
-    struct dbpf_bstream_rw_list_op *rw_op;
-    dbpf_queued_op_t *qop_p;
-    PVFS_size eor = -1;
-    int sync_required = 0;
-
-    rw_op = (struct dbpf_bstream_rw_list_op *)ptr;
-    qop_p = (dbpf_queued_op_t *)rw_op->queued_op_ptr;
-
-    ref.fs_id = qop_p->op.coll_p->coll_id;
-    ref.handle = qop_p->op.handle;
-
-    ret = dbpf_bstream_get_extents(
-        rw_op->mem_offset_array,
-        rw_op->mem_size_array,
-        rw_op->mem_array_count,
-        rw_op->stream_offset_array,
-        rw_op->stream_size_array,
-        rw_op->stream_array_count,
-        &extent_count,
-        NULL);
-    if(ret != 0)
-    {
-        gossip_err("%s: failed to count extents from stream offset/sizes: (error=%d)\n", __func__, ret);
-        goto cache_put;
-    }
-
-    stream_extents = malloc(sizeof(*stream_extents) * extent_count);
-    if(!stream_extents)
-    {
-        ret = -TROVE_ENOMEM;
-        goto cache_put;
-    }
-
-    ret = dbpf_bstream_get_extents(
-        rw_op->mem_offset_array,
-        rw_op->mem_size_array,
-        rw_op->mem_array_count,
-        rw_op->stream_offset_array,
-        rw_op->stream_size_array,
-        rw_op->stream_array_count,
-        &extent_count,
-        stream_extents);
-    if(ret != 0)
-    {
-        gossip_err("%s: failed to get stream extents from stream offset/sizes: (error=%d)\n", __func__, ret);
-        goto cache_put;
-    }
-
-    ret = dbpf_dspace_attr_get(qop_p->op.coll_p, ref, &attr);
-    if(ret != 0)
-    {
-        gossip_err("%s: failed to get dspace attr for bstream: (error=%d)\n", __func__, ret);
-        goto cache_put;
-    }
-
-    *rw_op->out_size_p = 0;
-    for(i = 0; i < extent_count; ++ i)
-    {
-        ret = direct_locked_write(rw_op->open_ref.fd,
-                                  stream_extents[i].buffer,
-                                  0,
-                                  stream_extents[i].size,
-                                  stream_extents[i].offset,
-                                  attr.u.datafile.b_size);
-        if(ret < 0)
-        {
-            gossip_err("%s: failed to perform direct locked write: (error=%d)\n", __func__, ret);
-            goto cache_put;
-        }
-
-        if(eor < stream_extents[i].offset + stream_extents[i].size)
-        {
-            eor = stream_extents[i].offset + stream_extents[i].size;
-        }
-
-        *rw_op->out_size_p += ret;
-    }
-
-    if(eor > attr.u.datafile.b_size)
-    {
-        int outcount;
-
-        gen_mutex_lock(&dbpf_update_size_lock);
-        ret = dbpf_dspace_attr_get(qop_p->op.coll_p, ref, &attr);
-        if(ret != 0)
-        {
-            gossip_err("%s: failed to get size from dspace attr: (error=%d)\n", __func__, ret);
-            gen_mutex_unlock(&dbpf_update_size_lock);
-            goto cache_put;
-        }
-
-        if(eor > attr.u.datafile.b_size)
-        {
-            /* set the size of the file */
-            attr.u.datafile.b_size = eor;
-            ret = dbpf_dspace_attr_set(qop_p->op.coll_p, ref, &attr);
-            if(ret != 0)
-            {
-                gossip_err("%s: failed to update size in dspace attr: (error=%d)\n", __func__, ret);
-                gen_mutex_unlock(&dbpf_update_size_lock);
-                goto cache_put;
-            }
-            sync_required = 1;
-        }
-        gen_mutex_unlock(&dbpf_update_size_lock);
-
-        if(sync_required == 1)
-        {
-            gossip_debug(GOSSIP_DIRECTIO_DEBUG, 
-                "directio updating size for handle %llu\n", llu(ref.handle));
-
-            dbpf_open_cache_put(&rw_op->open_ref);
-
-            /* If we updated the size, then convert cur_op into a setattr.
-             * Note that we are not actually going to perform a setattr.
-             * We just want the coalescing path to treat it like a setattr
-             * so that the size update is synced before we complete.
-             */
-            dbpf_queued_op_init(qop_p,
-                                DSPACE_SETATTR,
-                                ref.handle,
-                                qop_p->op.coll_p,
-                                dbpf_dspace_setattr_op_svc,
-                                qop_p->op.user_ptr,
-                                TROVE_SYNC,
-                                qop_p->op.context_id);
-            qop_p->op.state = OP_IN_SERVICE;
-            ret = dbpf_sync_coalesce(qop_p, 0, &outcount);
-            if(ret < 0)
-            {
-                gossip_err("%s: failed to coalesce size update in dspace attr: (error=%d)\n", __func__, ret);
-                goto done;
-            }
-
-            ret = PINT_MGMT_OP_CONTINUE;
-            goto done;
-        }
-    }
-
-    ret = PINT_MGMT_OP_COMPLETED;
-
-cache_put:
-    dbpf_open_cache_put(&rw_op->open_ref);
-done:
-    if(stream_extents)
-    {
-        free(stream_extents);
-    }
-    return ret;
+	int ret = -TROVE_EINVAL;
+	TROVE_object_ref ref;
+	TROVE_ds_attributes attr;
+	dbpf_stream_extents_t *stream_extents = NULL;
+	int i, extent_count;
+	struct dbpf_bstream_rw_list_op *rw_op;
+	dbpf_queued_op_t *qop_p;
+	PVFS_size eor = -1;
+	int sync_required = 0;
+
+	rw_op = (struct dbpf_bstream_rw_list_op *)ptr;
+	qop_p = (dbpf_queued_op_t *)rw_op->queued_op_ptr;
+
+	ref.fs_id = qop_p->op.coll_p->coll_id;
+	ref.handle = qop_p->op.handle;
+
+	ret = dbpf_bstream_get_extents(
+			rw_op->mem_offset_array,
+			rw_op->mem_size_array,
+			rw_op->mem_array_count,
+			rw_op->stream_offset_array,
+			rw_op->stream_size_array,
+			rw_op->stream_array_count,
+			&extent_count,
+			NULL);
+	if(ret != 0)
+	{
+		gossip_err("%s: failed to count extents from stream offset/sizes: (error=%d)\n", __func__, ret);
+		goto cache_put;
+	}
+
+	stream_extents = malloc(sizeof(*stream_extents) * extent_count);
+	if(!stream_extents)
+	{
+		ret = -TROVE_ENOMEM;
+		goto cache_put;
+	}
+
+	ret = dbpf_bstream_get_extents(
+			rw_op->mem_offset_array,
+			rw_op->mem_size_array,
+			rw_op->mem_array_count,
+			rw_op->stream_offset_array,
+			rw_op->stream_size_array,
+			rw_op->stream_array_count,
+			&extent_count,
+			stream_extents);
+	if(ret != 0)
+	{
+		gossip_err("%s: failed to get stream extents from stream offset/sizes: (error=%d)\n", __func__, ret);
+		goto cache_put;
+	}
+
+	ret = dbpf_dspace_attr_get(qop_p->op.coll_p, ref, &attr);
+	if(ret != 0)
+	{
+		gossip_err("%s: failed to get dspace attr for bstream: (error=%d)\n", __func__, ret);
+		goto cache_put;
+	}
+
+	*rw_op->out_size_p = 0;
+	for(i = 0; i < extent_count; ++ i)
+	{
+
+		HD_SERVER_TROVE_RELATION(hint,"write",
+				ret = direct_locked_write(rw_op->open_ref.fd,
+						stream_extents[i].buffer,
+						0,
+						stream_extents[i].size,
+						stream_extents[i].offset,
+						attr.u.datafile.b_size);,
+				"%d",ret,
+				"%lld",lld(stream_extents[i].offset)
+		)
+
+		if(ret < 0)
+		{
+			gossip_err("%s: failed to perform direct locked write: (error=%d)\n", __func__, ret);
+			goto cache_put;
+		}
+
+		if(eor < stream_extents[i].offset + stream_extents[i].size)
+		{
+			eor = stream_extents[i].offset + stream_extents[i].size;
+		}
+
+		*rw_op->out_size_p += ret;
+	}
+
+	if(eor > attr.u.datafile.b_size)
+	{
+		int outcount;
+
+		gen_mutex_lock(&dbpf_update_size_lock);
+		ret = dbpf_dspace_attr_get(qop_p->op.coll_p, ref, &attr);
+		if(ret != 0)
+		{
+			gossip_err("%s: failed to get size from dspace attr: (error=%d)\n", __func__, ret);
+			gen_mutex_unlock(&dbpf_update_size_lock);
+			goto cache_put;
+		}
+
+		if(eor > attr.u.datafile.b_size)
+		{
+			/* set the size of the file */
+			attr.u.datafile.b_size = eor;
+			ret = dbpf_dspace_attr_set(qop_p->op.coll_p, ref, &attr);
+			if(ret != 0)
+			{
+				gossip_err("%s: failed to update size in dspace attr: (error=%d)\n", __func__, ret);
+				gen_mutex_unlock(&dbpf_update_size_lock);
+				goto cache_put;
+			}
+			sync_required = 1;
+		}
+		gen_mutex_unlock(&dbpf_update_size_lock);
+
+		if(sync_required == 1)
+		{
+			gossip_debug(GOSSIP_DIRECTIO_DEBUG, 
+					"directio updating size for handle %llu\n", llu(ref.handle));
+
+			dbpf_open_cache_put(&rw_op->open_ref);
+
+			/* If we updated the size, then convert cur_op into a setattr.
+			 * Note that we are not actually going to perform a setattr.
+			 * We just want the coalescing path to treat it like a setattr
+			 * so that the size update is synced before we complete.
+			 */
+			dbpf_queued_op_init(qop_p,
+					DSPACE_SETATTR,
+					ref.handle,
+					qop_p->op.coll_p,
+					dbpf_dspace_setattr_op_svc,
+					qop_p->op.user_ptr,
+					TROVE_SYNC,
+					qop_p->op.context_id);
+			qop_p->op.state = OP_IN_SERVICE;
+			ret = dbpf_sync_coalesce(qop_p, 0, &outcount);
+			if(ret < 0)
+			{
+				gossip_err("%s: failed to coalesce size update in dspace attr: (error=%d)\n", __func__, ret);
+				goto done;
+			}
+
+			ret = PINT_MGMT_OP_CONTINUE;
+			goto done;
+		}
+	}
+
+	ret = PINT_MGMT_OP_COMPLETED;
+
+	cache_put:
+	dbpf_open_cache_put(&rw_op->open_ref);
+	done:
+	if(stream_extents)
+	{
+		free(stream_extents);
+	}
+	return ret;
 }
 
 static int dbpf_bstream_direct_read_at(TROVE_coll_id coll_id,
-                                       TROVE_handle handle,
-                                       void *buffer,
-                                       TROVE_size *inout_size_p,
-                                       TROVE_offset offset,
-                                       TROVE_ds_flags flags,
-                                       TROVE_vtag_s *vtag,
-                                       void *user_ptr,
-                                       TROVE_context_id context_id,
-                                       TROVE_op_id *out_op_id_p,
-				       PVFS_hint hints)
+		TROVE_handle handle,
+		void *buffer,
+		TROVE_size *inout_size_p,
+		TROVE_offset offset,
+		TROVE_ds_flags flags,
+		TROVE_vtag_s *vtag,
+		void *user_ptr,
+		TROVE_context_id context_id,
+		TROVE_op_id *out_op_id_p,
+		PVFS_hint hints)
 {
-    return -TROVE_ENOSYS;
+	return -TROVE_ENOSYS;
 }
 
 static int dbpf_bstream_direct_write_at(TROVE_coll_id coll_id,
-                                        TROVE_handle handle,
-                                        void *buffer,
-                                        TROVE_size *inout_size_p,
-                                        TROVE_offset offset,
-                                        TROVE_ds_flags flags,
-                                        TROVE_vtag_s *vtag,
-                                        void *user_ptr,
-                                        TROVE_context_id context_id,
-                                        TROVE_op_id *out_op_id_p,
-					PVFS_hint hints)
+		TROVE_handle handle,
+		void *buffer,
+		TROVE_size *inout_size_p,
+		TROVE_offset offset,
+		TROVE_ds_flags flags,
+		TROVE_vtag_s *vtag,
+		void *user_ptr,
+		TROVE_context_id context_id,
+		TROVE_op_id *out_op_id_p,
+		PVFS_hint hints)
 {
-    return -TROVE_ENOSYS;
+	return -TROVE_ENOSYS;
 }
 
 static int dbpf_bstream_direct_read_list(TROVE_coll_id coll_id,
-                                         TROVE_handle handle,
-                                         char **mem_offset_array, 
-                                         TROVE_size *mem_size_array,
-                                         int mem_count,
-                                         TROVE_offset *stream_offset_array,
-                                         TROVE_size *stream_size_array,
-                                         int stream_count,
-                                         TROVE_size *out_size_p,
-                                         TROVE_ds_flags flags, 
-                                         TROVE_vtag_s *vtag,
-                                         void *user_ptr,
-                                         TROVE_context_id context_id,
-                                         TROVE_op_id *out_op_id_p,
-                                         PVFS_hint hints)
+		TROVE_handle handle,
+		char **mem_offset_array, 
+		TROVE_size *mem_size_array,
+		int mem_count,
+		TROVE_offset *stream_offset_array,
+		TROVE_size *stream_size_array,
+		int stream_count,
+		TROVE_size *out_size_p,
+		TROVE_ds_flags flags, 
+		TROVE_vtag_s *vtag,
+		void *user_ptr,
+		TROVE_context_id context_id,
+		TROVE_op_id *out_op_id_p,
+		PVFS_hint hints)
 {
 
-    dbpf_queued_op_t *q_op_p = NULL;
-    struct dbpf_bstream_rw_list_op *op;
-    struct dbpf_collection *coll_p = NULL;
-    int ret;
-
-    coll_p = dbpf_collection_find_registered(coll_id);
-    if (coll_p == NULL)
-    {
-        gossip_err("%s: failed to find collection with fsid %d\n", __func__, coll_id);
-        return -TROVE_EINVAL;
-    }
-
-    q_op_p = dbpf_queued_op_alloc();
-    if (q_op_p == NULL)
-    {
-        return -TROVE_ENOMEM;
-    }
-
-    /* initialize all the common members */
-    dbpf_queued_op_init(q_op_p,
-                        BSTREAM_READ_LIST,
-                        handle,
-                        coll_p,
-                        NULL,
-                        user_ptr,
-                        flags,
-                        context_id);
-    op = (struct dbpf_bstream_rw_list_op *)&q_op_p->op.u.b_rw_list;
-
-    /* initialize the op-specific members */
-    op->stream_array_count = stream_count;
-    op->stream_offset_array = stream_offset_array;
-    op->stream_size_array = stream_size_array;
-    op->out_size_p = out_size_p;
-
-    op->mem_array_count = mem_count;
-    op->mem_offset_array = mem_offset_array;
-    op->mem_size_array = mem_size_array;
-    op->queued_op_ptr = q_op_p;
-
-    ret = dbpf_open_cache_get(
-        coll_id, handle,
-        DBPF_FD_DIRECT_READ,
-        &op->open_ref);
-    if(ret < 0)
-    {
-        if(ret == -TROVE_ENOENT)
-        {
-            /* We create the bstream lazily, so here we'll just assume the read
-             * was done before writes to this bstream occured, and return
-             * a successful read of size 0.
-             */
-            *out_size_p = 0;
-            ret = DBPF_OP_COMPLETE;
-        }
-        dbpf_queued_op_free(q_op_p);
-        return ret;
-    }
-
-    *out_op_id_p = q_op_p->op.id;
-    ret = PINT_manager_id_post(
-        io_thread_mgr, q_op_p, &q_op_p->mgr_op_id,
-        dbpf_bstream_direct_read_op_svc, op, NULL, io_queue_id);
-    if(ret < 0)
-    {
-        gossip_err("%s: failed to post direct read op: (error=%d)\n", __func__, ret);
-        return ret;
-    }
-
-    return DBPF_OP_CONTINUE;
+	dbpf_queued_op_t *q_op_p = NULL;
+	struct dbpf_bstream_rw_list_op *op;
+	struct dbpf_collection *coll_p = NULL;
+	int ret;
+
+	coll_p = dbpf_collection_find_registered(coll_id);
+	if (coll_p == NULL)
+	{
+		gossip_err("%s: failed to find collection with fsid %d\n", __func__, coll_id);
+		return -TROVE_EINVAL;
+	}
+
+	q_op_p = dbpf_queued_op_alloc();
+	if (q_op_p == NULL)
+	{
+		return -TROVE_ENOMEM;
+	}
+
+	/* initialize all the common members */
+	dbpf_queued_op_init(q_op_p,
+			BSTREAM_READ_LIST,
+			handle,
+			coll_p,
+			NULL,
+			user_ptr,
+			flags,
+			context_id);
+	op = (struct dbpf_bstream_rw_list_op *)&q_op_p->op.u.b_rw_list;
+
+	/* initialize the op-specific members */
+	op->stream_array_count = stream_count;
+	op->stream_offset_array = stream_offset_array;
+	op->stream_size_array = stream_size_array;
+	op->out_size_p = out_size_p;
+
+	op->mem_array_count = mem_count;
+	op->mem_offset_array = mem_offset_array;
+	op->mem_size_array = mem_size_array;
+	op->queued_op_ptr = q_op_p;
+
+	ret = dbpf_open_cache_get(
+			coll_id, handle,
+			DBPF_FD_DIRECT_READ,
+			&op->open_ref);
+	if(ret < 0)
+	{
+		if(ret == -TROVE_ENOENT)
+		{
+			/* We create the bstream lazily, so here we'll just assume the read
+			 * was done before writes to this bstream occured, and return
+			 * a successful read of size 0.
+			 */
+			*out_size_p = 0;
+			ret = DBPF_OP_COMPLETE;
+		}
+		dbpf_queued_op_free(q_op_p);
+		return ret;
+	}
+
+	*out_op_id_p = q_op_p->op.id;
+	ret = PINT_manager_id_post(
+			io_thread_mgr, q_op_p, &q_op_p->mgr_op_id,
+			//			dbpf_bstream_direct_read_op_svc, op, NULL, io_queue_id);
+			dbpf_bstream_direct_read_op_svc, op, hints, io_queue_id);
+	if(ret < 0)
+	{
+		gossip_err("%s: failed to post direct read op: (error=%d)\n", __func__, ret);
+		return ret;
+	}
+
+	return DBPF_OP_CONTINUE;
 }
 
 static int dbpf_bstream_direct_write_list(TROVE_coll_id coll_id,
-                                          TROVE_handle handle,
-                                          char **mem_offset_array,
-                                          TROVE_size *mem_size_array,
-                                          int mem_count,
-                                          TROVE_offset *stream_offset_array,
-                                          TROVE_size *stream_size_array,
-                                          int stream_count,
-                                          TROVE_size *out_size_p,
-                                          TROVE_ds_flags flags, 
-                                          TROVE_vtag_s *vtag,
-                                          void *user_ptr,
-                                          TROVE_context_id context_id,
-                                          TROVE_op_id *out_op_id_p,
-                                          PVFS_hint hints)
+		TROVE_handle handle,
+		char **mem_offset_array,
+		TROVE_size *mem_size_array,
+		int mem_count,
+		TROVE_offset *stream_offset_array,
+		TROVE_size *stream_size_array,
+		int stream_count,
+		TROVE_size *out_size_p,
+		TROVE_ds_flags flags, 
+		TROVE_vtag_s *vtag,
+		void *user_ptr,
+		TROVE_context_id context_id,
+		TROVE_op_id *out_op_id_p,
+		PVFS_hint hints)
 {
 
-    dbpf_queued_op_t *q_op_p = NULL;
-    struct dbpf_bstream_rw_list_op *op;
-    struct dbpf_collection *coll_p = NULL;
-    int ret;
-
-    coll_p = dbpf_collection_find_registered(coll_id);
-    if (coll_p == NULL)
-    {
-        return -TROVE_EINVAL;
-    }
-
-    q_op_p = dbpf_queued_op_alloc();
-    if(!q_op_p)
-    {
-        return -TROVE_ENOMEM;
-    }
-    dbpf_queued_op_init(q_op_p,
-                        BSTREAM_WRITE_LIST,
-                        handle,
-                        coll_p,
-                        NULL,
-                        user_ptr,
-                        0,
-                        context_id);
-
-    op = &q_op_p->op.u.b_rw_list;
-
-    /* initialize the op-specific members */
-    op->stream_array_count = stream_count;
-    op->stream_offset_array = stream_offset_array;
-    op->stream_size_array = stream_size_array;
-    op->out_size_p = out_size_p;
-
-    op->mem_array_count = mem_count;
-    op->mem_offset_array = mem_offset_array;
-    op->mem_size_array = mem_size_array;
-    op->queued_op_ptr = q_op_p;
-
-    ret = dbpf_open_cache_get(
-        coll_id, handle,
-        DBPF_FD_DIRECT_WRITE,
-        &op->open_ref);
-    if(ret < 0)
-    {
-        dbpf_queued_op_free(q_op_p);
-        return ret;
-    }
-
-    *out_op_id_p = q_op_p->op.id;
-
-    gossip_debug(GOSSIP_DIRECTIO_DEBUG, "%s: queuing direct write operation\n", __func__);
-    PINT_manager_id_post(
-        io_thread_mgr, q_op_p, &q_op_p->mgr_op_id,
-        dbpf_bstream_direct_write_op_svc, op, NULL, io_queue_id);
-
-    return DBPF_OP_CONTINUE;
+	dbpf_queued_op_t *q_op_p = NULL;
+	struct dbpf_bstream_rw_list_op *op;
+	struct dbpf_collection *coll_p = NULL;
+	int ret;
+
+	coll_p = dbpf_collection_find_registered(coll_id);
+	if (coll_p == NULL)
+	{
+		return -TROVE_EINVAL;
+	}
+
+	q_op_p = dbpf_queued_op_alloc();
+	if(!q_op_p)
+	{
+		return -TROVE_ENOMEM;
+	}
+	dbpf_queued_op_init(q_op_p,
+			BSTREAM_WRITE_LIST,
+			handle,
+			coll_p,
+			NULL,
+			user_ptr,
+			0,
+			context_id);
+
+	op = &q_op_p->op.u.b_rw_list;
+
+	/* initialize the op-specific members */
+	op->stream_array_count = stream_count;
+	op->stream_offset_array = stream_offset_array;
+	op->stream_size_array = stream_size_array;
+	op->out_size_p = out_size_p;
+
+	op->mem_array_count = mem_count;
+	op->mem_offset_array = mem_offset_array;
+	op->mem_size_array = mem_size_array;
+	op->queued_op_ptr = q_op_p;
+
+	ret = dbpf_open_cache_get(
+			coll_id, handle,
+			DBPF_FD_DIRECT_WRITE,
+			&op->open_ref);
+	if(ret < 0)
+	{
+		dbpf_queued_op_free(q_op_p);
+		return ret;
+	}
+
+	*out_op_id_p = q_op_p->op.id;
+
+	gossip_debug(GOSSIP_DIRECTIO_DEBUG, "%s: queuing direct write operation\n", __func__);
+	PINT_manager_id_post(
+			io_thread_mgr, q_op_p, &q_op_p->mgr_op_id,
+//			dbpf_bstream_direct_write_op_svc, op, NULL, io_queue_id);
+			dbpf_bstream_direct_write_op_svc, op, hints, io_queue_id);
+
+	return DBPF_OP_CONTINUE;
 }
 
 static int dbpf_bstream_direct_resize_op_svc(struct dbpf_op *op_p)
 {
-    int ret;
-    TROVE_ds_attributes attr;
-    TROVE_object_ref ref;
-    dbpf_queued_op_t *q_op_p;
-    struct open_cache_ref open_ref;
-    PVFS_size tmpsize;
-
-    q_op_p = (dbpf_queued_op_t *)op_p->u.b_resize.queued_op_ptr;
-    ref.fs_id = op_p->coll_p->coll_id;
-    ref.handle = op_p->handle;
-
-    gen_mutex_lock(&dbpf_update_size_lock);
-    ret = dbpf_dspace_attr_get(op_p->coll_p, ref, &attr);
-    if(ret != 0)
-    {
-        gen_mutex_unlock(&dbpf_update_size_lock);
-        return ret;
-    }
-
-    tmpsize = op_p->u.b_resize.size;
-    attr.u.datafile.b_size = tmpsize;
-
-    ret = dbpf_dspace_attr_set(op_p->coll_p, ref, &attr);
-    if(ret < 0)
-    {
-        gen_mutex_unlock(&dbpf_update_size_lock);
-        return ret;
-    }
-    gen_mutex_unlock(&dbpf_update_size_lock);
-
-    /* setup op for sync coalescing */
-    dbpf_queued_op_init(q_op_p,
-                        DSPACE_SETATTR,
-                        ref.handle,
-                        q_op_p->op.coll_p,
-                        dbpf_dspace_setattr_op_svc,
-                        q_op_p->op.user_ptr,
-                        TROVE_SYNC,
-                        q_op_p->op.context_id);
-    q_op_p->op.state = OP_IN_SERVICE;
-
-    /* truncate file after attributes are set */
-    ret = dbpf_open_cache_get(
-        op_p->coll_p->coll_id, op_p->handle,
-        DBPF_FD_DIRECT_WRITE,
-        &open_ref);
-    if(ret < 0)
-    {
-        return ret;
-    }
-
-    ret = DBPF_RESIZE(open_ref.fd, tmpsize);
-    if(ret < 0)
-    {
-        return(ret);
-    }
-
-    dbpf_open_cache_put(&open_ref);
-
-    return DBPF_OP_COMPLETE;
+	int ret;
+	TROVE_ds_attributes attr;
+	TROVE_object_ref ref;
+	dbpf_queued_op_t *q_op_p;
+	struct open_cache_ref open_ref;
+	PVFS_size tmpsize;
+
+	q_op_p = (dbpf_queued_op_t *)op_p->u.b_resize.queued_op_ptr;
+	ref.fs_id = op_p->coll_p->coll_id;
+	ref.handle = op_p->handle;
+
+	gen_mutex_lock(&dbpf_update_size_lock);
+	ret = dbpf_dspace_attr_get(op_p->coll_p, ref, &attr);
+	if(ret != 0)
+	{
+		gen_mutex_unlock(&dbpf_update_size_lock);
+		return ret;
+	}
+
+	tmpsize = op_p->u.b_resize.size;
+	attr.u.datafile.b_size = tmpsize;
+
+	ret = dbpf_dspace_attr_set(op_p->coll_p, ref, &attr);
+	if(ret < 0)
+	{
+		gen_mutex_unlock(&dbpf_update_size_lock);
+		return ret;
+	}
+	gen_mutex_unlock(&dbpf_update_size_lock);
+
+	/* setup op for sync coalescing */
+	dbpf_queued_op_init(q_op_p,
+			DSPACE_SETATTR,
+			ref.handle,
+			q_op_p->op.coll_p,
+			dbpf_dspace_setattr_op_svc,
+			q_op_p->op.user_ptr,
+			TROVE_SYNC,
+			q_op_p->op.context_id);
+	q_op_p->op.state = OP_IN_SERVICE;
+
+	/* truncate file after attributes are set */
+	ret = dbpf_open_cache_get(
+			op_p->coll_p->coll_id, op_p->handle,
+			DBPF_FD_DIRECT_WRITE,
+			&open_ref);
+	if(ret < 0)
+	{
+		return ret;
+	}
+
+	ret = DBPF_RESIZE(open_ref.fd, tmpsize);
+	if(ret < 0)
+	{
+		return(ret);
+	}
+
+	dbpf_open_cache_put(&open_ref);
+
+	return DBPF_OP_COMPLETE;
 }
 
 static int dbpf_bstream_direct_resize(TROVE_coll_id coll_id,
-                                      TROVE_handle handle,
-                                      TROVE_size *inout_size_p,
-                                      TROVE_ds_flags flags,
-                                      TROVE_vtag_s *vtag,
-                                      void *user_ptr,
-                                      TROVE_context_id context_id,
-                                      TROVE_op_id *out_op_id_p,
-				      PVFS_hint hints)
+		TROVE_handle handle,
+		TROVE_size *inout_size_p,
+		TROVE_ds_flags flags,
+		TROVE_vtag_s *vtag,
+		void *user_ptr,
+		TROVE_context_id context_id,
+		TROVE_op_id *out_op_id_p,
+		PVFS_hint hints)
 {
-    dbpf_queued_op_t *q_op_p = NULL;
-    struct dbpf_collection *coll_p = NULL;
-
-    coll_p = dbpf_collection_find_registered(coll_id);
-    if (coll_p == NULL)
-    {
-        return -TROVE_EINVAL;
-    }
-
-    q_op_p = dbpf_queued_op_alloc();
-    if (q_op_p == NULL)
-    {
-        return -TROVE_ENOMEM;
-    }
-
-    /* initialize all the common members */
-    dbpf_queued_op_init(q_op_p,
-                        BSTREAM_RESIZE,
-                        handle,
-                        coll_p,
-                        dbpf_bstream_direct_resize_op_svc,
-                        user_ptr,
-                        flags,
-                        context_id);
-
-    /* initialize the op-specific members */
-    q_op_p->op.u.b_resize.size = *inout_size_p;
-    q_op_p->op.u.b_resize.queued_op_ptr = q_op_p;
-    *out_op_id_p = dbpf_queued_op_queue(q_op_p);
-
-    return 0;
+	dbpf_queued_op_t *q_op_p = NULL;
+	struct dbpf_collection *coll_p = NULL;
+
+	coll_p = dbpf_collection_find_registered(coll_id);
+	if (coll_p == NULL)
+	{
+		return -TROVE_EINVAL;
+	}
+
+	q_op_p = dbpf_queued_op_alloc();
+	if (q_op_p == NULL)
+	{
+		return -TROVE_ENOMEM;
+	}
+
+	/* initialize all the common members */
+	dbpf_queued_op_init(q_op_p,
+			BSTREAM_RESIZE,
+			handle,
+			coll_p,
+			dbpf_bstream_direct_resize_op_svc,
+			user_ptr,
+			flags,
+			context_id);
+
+	/* initialize the op-specific members */
+	q_op_p->op.u.b_resize.size = *inout_size_p;
+	q_op_p->op.u.b_resize.queued_op_ptr = q_op_p;
+	*out_op_id_p = dbpf_queued_op_queue(q_op_p);
+
+	return 0;
 }
 
 static int dbpf_bstream_direct_validate(TROVE_coll_id coll_id,
-                                        TROVE_handle handle,
-                                        TROVE_ds_flags flags,
-                                        TROVE_vtag_s *vtag,
-                                        void *user_ptr,
-                                        TROVE_context_id context_id,
-                                        TROVE_op_id *out_op_id_p,
-                                        PVFS_hint hints)
+		TROVE_handle handle,
+		TROVE_ds_flags flags,
+		TROVE_vtag_s *vtag,
+		void *user_ptr,
+		TROVE_context_id context_id,
+		TROVE_op_id *out_op_id_p,
+		PVFS_hint hints)
 {
-    return -TROVE_ENOSYS;
+	return -TROVE_ENOSYS;
 }
 
 static int dbpf_bstream_direct_flush(TROVE_coll_id coll_id,
-                                     TROVE_handle handle,
-                                     TROVE_ds_flags flags,
-                                     void *user_ptr,
-                                     TROVE_context_id context_id,
-                                     TROVE_op_id *out_op_id_p,
-                                     PVFS_hint hints)
+		TROVE_handle handle,
+		TROVE_ds_flags flags,
+		void *user_ptr,
+		TROVE_context_id context_id,
+		TROVE_op_id *out_op_id_p,
+		PVFS_hint hints)
 {
-    return DBPF_OP_COMPLETE;
+	return DBPF_OP_COMPLETE;
 }
 
 static int dbpf_bstream_direct_cancel(
-    TROVE_coll_id coll_id,
-    TROVE_op_id cancel_id,
-    TROVE_context_id context_id)
+		TROVE_coll_id coll_id,
+		TROVE_op_id cancel_id,
+		TROVE_context_id context_id)
 {
-    dbpf_queued_op_t *op;
-    int ret;
-
-    op = id_gen_fast_lookup(cancel_id);
-    if(!op)
-    {
-        gossip_lerr("Invalid op-id to cancel\n");
-        return -TROVE_EINVAL;
-    }
-
-    ret = PINT_manager_cancel(io_thread_mgr, op->mgr_op_id);
-    if(ret < 0)
-    {
-        return ret|PVFS_ERROR_TROVE;
-    }
-
-    return ret;
+	dbpf_queued_op_t *op;
+	int ret;
+
+	op = id_gen_fast_lookup(cancel_id);
+	if(!op)
+	{
+		gossip_lerr("Invalid op-id to cancel\n");
+		return -TROVE_EINVAL;
+	}
+
+	ret = PINT_manager_cancel(io_thread_mgr, op->mgr_op_id);
+	if(ret < 0)
+	{
+		return ret|PVFS_ERROR_TROVE;
+	}
+
+	return ret;
 }
 
 struct TROVE_bstream_ops dbpf_bstream_direct_ops =
 {
-    dbpf_bstream_direct_read_at,
-    dbpf_bstream_direct_write_at,
-    dbpf_bstream_direct_resize,
-    dbpf_bstream_direct_validate,
-    dbpf_bstream_direct_read_list,
-    dbpf_bstream_direct_write_list,
-    dbpf_bstream_direct_flush,
-    dbpf_bstream_direct_cancel
+		dbpf_bstream_direct_read_at,
+		dbpf_bstream_direct_write_at,
+		dbpf_bstream_direct_resize,
+		dbpf_bstream_direct_validate,
+		dbpf_bstream_direct_read_list,
+		dbpf_bstream_direct_write_list,
+		dbpf_bstream_direct_flush,
+		dbpf_bstream_direct_cancel
 };
 
 static int dbpf_bstream_get_extents(
-    char **mem_offset_array,
-    TROVE_size *mem_size_array,
-    int mem_count,
-    TROVE_offset *stream_offset_array,
-    TROVE_size *stream_size_array,
-    int stream_count,
-    int *ext_count,
-    dbpf_stream_extents_t *extents)
+		char **mem_offset_array,
+		TROVE_size *mem_size_array,
+		int mem_count,
+		TROVE_offset *stream_offset_array,
+		TROVE_size *stream_size_array,
+		int stream_count,
+		int *ext_count,
+		dbpf_stream_extents_t *extents)
 {
-    int mct = 0, sct = 0, act = 0;
-    int oom = 0, oos = 0;
-    TROVE_size cur_mem_size = 0;
-    char *cur_mem_off = NULL;
-    char *ext_ptr = NULL;
-    TROVE_size ext_size = 0, cur_stream_size = 0;
-    TROVE_offset ext_off = 0, cur_stream_off = 0;
-
-    cur_mem_size = mem_size_array[mct];
-    cur_mem_off = mem_offset_array[mct];
-
-    cur_stream_size = stream_size_array[sct];
-    cur_stream_off = stream_offset_array[sct];
-
-    while (1)
-    {
-        /*
+	int mct = 0, sct = 0, act = 0;
+	int oom = 0, oos = 0;
+	TROVE_size cur_mem_size = 0;
+	char *cur_mem_off = NULL;
+	char *ext_ptr = NULL;
+	TROVE_size ext_size = 0, cur_stream_size = 0;
+	TROVE_offset ext_off = 0, cur_stream_off = 0;
+
+	cur_mem_size = mem_size_array[mct];
+	cur_mem_off = mem_offset_array[mct];
+
+	cur_stream_size = stream_size_array[sct];
+	cur_stream_off = stream_offset_array[sct];
+
+	while (1)
+	{
+		/*
           determine if we're either out of memory (oom) regions, or
           out of stream (oos) regions
-        */
-        /* in many (all?) cases mem_count is 1, so oom will end up being 1 */
-        oom = (((mct + 1) < mem_count) ? 0 : 1);
-        oos = (((sct + 1) < stream_count) ? 0 : 1);
-
-        if (cur_mem_size == cur_stream_size)
-        {
-            /* consume both mem and stream regions */
-            ext_size = cur_mem_size;
-            ext_ptr = cur_mem_off;
-            ext_off = cur_stream_off;
-
-            if (!oom)
-            {
-                cur_mem_size = mem_size_array[++mct];
-                cur_mem_off  = mem_offset_array[mct];
-            }
-            else
-            {
-                cur_mem_size = 0;
-            }
-            if (!oos)
-            {
-                cur_stream_size = stream_size_array[++sct];
-                cur_stream_off  = stream_offset_array[sct];
-            }
-            else
-            {
-                cur_stream_size = 0;
-            }
-        }
-        else if (cur_mem_size < cur_stream_size)
-        {
-            /* consume mem region and update stream region */
-            ext_size = cur_mem_size;
-            ext_ptr = cur_mem_off;
-            ext_off = cur_stream_off;
-
-            cur_stream_size -= cur_mem_size;
-            cur_stream_off  += cur_mem_size;
-
-            if (!oom)
-            {
-                cur_mem_size = mem_size_array[++mct];
-                cur_mem_off  = mem_offset_array[mct];
-            }
-            else
-            {
-                cur_mem_size = 0;
-            }
-        }
-        else /* cur_mem_size > cur_stream_size */
-        {
-            /* consume stream region and update mem region */
-            ext_size = cur_stream_size;
-
-            cur_mem_size -= cur_stream_size;
-            cur_mem_off  += cur_stream_size;
-
-            if (!oos)
-            {
-                cur_stream_size = stream_size_array[++sct];
-                cur_stream_off  = stream_offset_array[sct];
-            }
-            else
-            {
-                cur_stream_size = 0;
-            }
-        }
-
-        if(extents)
-        {
-            extents[act].buffer = ext_ptr;
-            extents[act].offset = ext_off;
-            extents[act].size =   ext_size;
-        }
-        act++;
-
-        /* process until there are no bytes left in the current piece */
-        if ((oom && cur_mem_size == 0) || (oos && cur_stream_size == 0))
-        {
-            break;
-        }
-    }
-
-    /* return the number actually used */
-    *ext_count = act;
-    return 0;
+		 */
+		/* in many (all?) cases mem_count is 1, so oom will end up being 1 */
+		oom = (((mct + 1) < mem_count) ? 0 : 1);
+		oos = (((sct + 1) < stream_count) ? 0 : 1);
+
+		if (cur_mem_size == cur_stream_size)
+		{
+			/* consume both mem and stream regions */
+			ext_size = cur_mem_size;
+			ext_ptr = cur_mem_off;
+			ext_off = cur_stream_off;
+
+			if (!oom)
+			{
+				cur_mem_size = mem_size_array[++mct];
+				cur_mem_off  = mem_offset_array[mct];
+			}
+			else
+			{
+				cur_mem_size = 0;
+			}
+			if (!oos)
+			{
+				cur_stream_size = stream_size_array[++sct];
+				cur_stream_off  = stream_offset_array[sct];
+			}
+			else
+			{
+				cur_stream_size = 0;
+			}
+		}
+		else if (cur_mem_size < cur_stream_size)
+		{
+			/* consume mem region and update stream region */
+			ext_size = cur_mem_size;
+			ext_ptr = cur_mem_off;
+			ext_off = cur_stream_off;
+
+			cur_stream_size -= cur_mem_size;
+			cur_stream_off  += cur_mem_size;
+
+			if (!oom)
+			{
+				cur_mem_size = mem_size_array[++mct];
+				cur_mem_off  = mem_offset_array[mct];
+			}
+			else
+			{
+				cur_mem_size = 0;
+			}
+		}
+		else /* cur_mem_size > cur_stream_size */
+		{
+			/* consume stream region and update mem region */
+			ext_size = cur_stream_size;
+
+			cur_mem_size -= cur_stream_size;
+			cur_mem_off  += cur_stream_size;
+
+			if (!oos)
+			{
+				cur_stream_size = stream_size_array[++sct];
+				cur_stream_off  = stream_offset_array[sct];
+			}
+			else
+			{
+				cur_stream_size = 0;
+			}
+		}
+
+		if(extents)
+		{
+			extents[act].buffer = ext_ptr;
+			extents[act].offset = ext_off;
+			extents[act].size =   ext_size;
+		}
+		act++;
+
+		/* process until there are no bytes left in the current piece */
+		if ((oom && cur_mem_size == 0) || (oos && cur_stream_size == 0))
+		{
+			break;
+		}
+	}
+
+	/* return the number actually used */
+	*ext_count = act;
+	return 0;
 }
 
 #if 0
 int dbpf_aligned_blocks_init(void)
 {
-    int i;
-
-    aligned_blocks_buffer = PINT_mem_aligned_alloc(BLOCK_SIZE*256, BLOCK_SIZE);
-    blocks = malloc(sizeof(*blocks) * 256);
-    used_count = 0;
-    gen_mutex_lock(&aligned_blocks_mutex);
-    for(i = 0; i < 256; ++i)
-    {
-        blocks[i].ptr = ((char *)aligned_blocks_buffer) + (i*BLOCK_SIZE);
-        qlist_add_tail(&(blocks[i].link), &aligned_blocks_unused);
-    }
-    gen_mutex_unlock(&aligned_blocks_mutex);
-    return 0;
+	int i;
+
+	aligned_blocks_buffer = PINT_mem_aligned_alloc(BLOCK_SIZE*256, BLOCK_SIZE);
+	blocks = malloc(sizeof(*blocks) * 256);
+	used_count = 0;
+	gen_mutex_lock(&aligned_blocks_mutex);
+	for(i = 0; i < 256; ++i)
+	{
+		blocks[i].ptr = ((char *)aligned_blocks_buffer) + (i*BLOCK_SIZE);
+		qlist_add_tail(&(blocks[i].link), &aligned_blocks_unused);
+	}
+	gen_mutex_unlock(&aligned_blocks_mutex);
+	return 0;
 }
 
 int dbpf_aligned_blocks_finalize(void)
 {
-    free(blocks);
-    PINT_mem_aligned_free(aligned_blocks_buffer);
-    return 0;
+	free(blocks);
+	PINT_mem_aligned_free(aligned_blocks_buffer);
+	return 0;
 }
 
 void *dbpf_aligned_block_get(void)
 {
-    void *ptr;
-    struct aligned_block *ablock;
-    gen_mutex_lock(&aligned_blocks_mutex);
-    if(used_count > 255)
-    {
-        gossip_debug(GOSSIP_DIRECTIO_DEBUG, "ran out of aligned blocks: %d\n",
-                     used_count);
-        gen_mutex_unlock(&aligned_blocks_mutex);
-        return NULL;
-    }
-    if(qlist_empty(&aligned_blocks_unused))
-    {
-	gossip_debug(GOSSIP_DIRECTIO_DEBUG,
-                     "aligned_block_get: unused list empty.\n");
-        gen_mutex_unlock(&aligned_blocks_mutex);
-        return NULL;
-    }
-
-    ablock = qlist_entry(aligned_blocks_unused.next, struct aligned_block, link);
-    qlist_del(&ablock->link);
-    ptr = ablock->ptr;
-    ablock->ptr = NULL;
-    qlist_add_tail(&ablock->link, &aligned_blocks_used);
-    ++used_count;
-    gen_mutex_unlock(&aligned_blocks_mutex);
-    return ptr;
+	void *ptr;
+	struct aligned_block *ablock;
+	gen_mutex_lock(&aligned_blocks_mutex);
+	if(used_count > 255)
+	{
+		gossip_debug(GOSSIP_DIRECTIO_DEBUG, "ran out of aligned blocks: %d\n",
+				used_count);
+		gen_mutex_unlock(&aligned_blocks_mutex);
+		return NULL;
+	}
+	if(qlist_empty(&aligned_blocks_unused))
+	{
+		gossip_debug(GOSSIP_DIRECTIO_DEBUG,
+				"aligned_block_get: unused list empty.\n");
+		gen_mutex_unlock(&aligned_blocks_mutex);
+		return NULL;
+	}
+
+	ablock = qlist_entry(aligned_blocks_unused.next, struct aligned_block, link);
+	qlist_del(&ablock->link);
+	ptr = ablock->ptr;
+	ablock->ptr = NULL;
+	qlist_add_tail(&ablock->link, &aligned_blocks_used);
+	++used_count;
+	gen_mutex_unlock(&aligned_blocks_mutex);
+	return ptr;
 }
 
 int dbpf_aligned_block_put(void *ptr)
 {
-    struct aligned_block *ablock;
-
-    gen_mutex_lock(&aligned_blocks_mutex);
-    ablock = qlist_entry(aligned_blocks_used.next, struct aligned_block, link);
-    qlist_del(&ablock->link);
-    ablock->ptr = ptr;
-    qlist_add_tail((&(ablock->link)), &aligned_blocks_unused);
-    --used_count;
-    gen_mutex_unlock(&aligned_blocks_mutex);
-    return 0;
+	struct aligned_block *ablock;
+
+	gen_mutex_lock(&aligned_blocks_mutex);
+	ablock = qlist_entry(aligned_blocks_used.next, struct aligned_block, link);
+	qlist_del(&ablock->link);
+	ablock->ptr = ptr;
+	qlist_add_tail((&(ablock->link)), &aligned_blocks_unused);
+	--used_count;
+	gen_mutex_unlock(&aligned_blocks_mutex);
+	return 0;
 }
 #endif
 
